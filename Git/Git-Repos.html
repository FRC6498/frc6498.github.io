<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@200..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/global.css">
  <link href="../css/colors.css" rel="stylesheet">
  <link rel="stylesheet" href="../css/doc-page.css">
  <title>Document</title>
</head>

<body>
  <div class="header">
    <a href="../index.html"><img src="../assets/left-arrow.png" alt="Back" height="40" width="40"></a> <!--back button-->
    <div>
      <h1>Git Repositories</h1>
    </div>
    <div></div> <!--placeholder so title is centered-->
  </div>
  <div class="container">
    <div class="outline">
      <div class="outline-content">
        <ul>
          <li><a href="#Features">Features</a></li>
          <li><a href="#Creation">Creation</a></li>
          <li><a href="#Adding Files">Adding Files</a></li>
          <li><a href="#Commiting Files">Commiting Files</a></li>
          <li><a href="#Commit Log">Commit Log</a></li>
          <li><a href="#Reversion">Reversion</a></li>
        </ul>
      </div>
    </div>
    <div class="main">
      <p>
        Git is designed to keep track of the entire history of your code as you go through the development process.
        Git stores snapshots of your code in packages called 'commits'. These commits have data on who wrote what code,
        when the code was written, and
        what code was written. With git, you are able to revert your entire codebase back to the state it was in when
        you made a commit. This is useful when
        writing large amounts of code with many features that may break other parts of the codebase.
      </p>
      <h1 id="Features">Features</h1>
      <h3>Branches</h3>
      <p>
        Git Repositories are like a branch on a tree. There is the main branch that is created with the repository, and
        you can define other branches depending on the code you are writing.
        Branches are most useful when you are writing a new feature that you want to keep seperate from the rest of the
        codebase untill it is finished. Commits that are made to a branch will
        not affect any other branches. More info <a href="Branches.html">Here</a>
      </p>
      <h3>Commit Reversion</h3>
      <p>
        The whole point of using git is to protect yourself from making completly unrecoverable mistakes. If you manage
        to write a large piece of new code that completly breaks your project,
        then it is possible to revert your code back to a point where it was still working. Doing this does not delete
        the code that you reverted from. Because of this, you can switch back
        and forth to rewrite your code so it actually works this time.
      </p>
      <h1>Usage</h1>
      <p>All following information assumes you are using Git from the command line. For information on using the git GUI in
        vscode, look <a href="../Github/Vscode-Git.html">Here</a></p>
      <h3 id="Creation">Creation</h3>
      <p class="code-example">> git init</p>
      <p>
        This command creates an empty Git repository - basically a .git directory with subdirectories for objects,
        refs/heads, refs/tags, and template files. An initial branch without any commits will be created.
      </p>
      <p>
        If the GIT_DIR environment variable is set then it specifies a path to use instead of ./.git for the base of the
        repository.
      </p>
      <p>
        Running git init in an existing repository is safe. It will not overwrite things that are already there. The
        primary reason for rerunning git init is to pick up newly added templates.
      </p>
      <h3 id="Adding Files">Adding Files</h3>
      <p class="code-example">> git add (filename or directory)</p>
      <p>
        This command updates the index using the current content found in the working tree, to prepare the content
        staged for the next commit. It typically adds the current content of existing paths as a whole, but with some
        options it can also be used to add content with only part of the changes made to the working tree files applied,
        or remove paths that do not exist in the working tree anymore.
      </p>
      <p>
        The "index" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the
        contents of the next commit. Thus after making any changes to the working tree, and before running the commit
        command, you must use the add command to add any new or modified files to the index.
      </p>
      <p>
        This command can be performed multiple times before a commit. It only adds the content of the specified file(s)
        at the time the add command is run; if you want subsequent changes included in the next commit, then you must
        run git add again to add the new content to the index.
      </p>
      <p>
        The git status command can be used to obtain a summary of which files have changes that are staged for the next
        commit.
      </p>
      <p>
        The git add command will not add ignored files by default. If any ignored files were explicitly specified on the
        command line, git add will fail with a list of ignored files. Ignored files reached by directory recursion or
        filename globbing performed by Git will be silently ignored (no errors will be printed to console). The git add
        command can be used to add ignored files with the -f (force) option.
      </p>
      <h3 id="Commiting Files">Commiting Files</h3>
      <h4>Step 1</h4>
      <p class="code-example">> git stage (filename)</p>
      <p>This command does the same thing as git add (both will work). All changes made to tracked files must be added
        to the index before commiting. </p>
        <p>To add all previously known files use the <span class="code-example-inline">--all</span> option without a filename</p>
      <h4>Step 2</h4>
      <p class="code-example">> git commit -m "(commit message)"</p>
      <p>
        Create a new commit containing the current contents of the index and the given log message describing the
        changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is
        updated to point to it. 
      </p>
      <p>
        The --dry-run option can be used to obtain a summary of what is included by any of the above for the next commit
        by giving the same set of parameters (options and paths).
      </p>
      <p>
          If you make a commit and then find a mistake immediately after that, you can recover from it with <span class="code-example-inline">> git reset</span>
      </p>
      <h3 id="Commit Log">Viewing Commit log</h3>
      <p class="code-example">> git log</p>
    </div>
  </div>
</body>

</html>
